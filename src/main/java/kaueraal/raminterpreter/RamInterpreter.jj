PARSER_BEGIN(RamInterpreter)
package kaueraal.raminterpreter;

import java.util.Vector;
import java.util.HashMap;
import java.io.*;

public class RamInterpreter
{
	/* parsed instruction */
	private Vector<Instruction> instructions; 

	/* original code, line by line, starting with 0 */
	private Vector<String> code;

	public void setCode(Vector<String> code)
	{
		this.code = code;
	}

	/* mapping: label -> next instruction */
	private HashMap<String,Integer> labels;

	/* Parses the program, which was set at the constructor.
	 * Returns whether parsing was successfull */
	public boolean parse()
	{
		try
		{
			instructions = new Vector<Instruction>();
			labels = new HashMap<String,Integer>();

			/* Original code is inserted by the autogenerated constructors of javacc, we only
			 * have to call statements() */
			statements(instructions, labels);
		}
		catch(ParseException e)
		{
			System.err.println(String.format("Error during parsing: %s", e.getMessage()));
			return false;
		}
		catch(TokenMgrError e)
		{
			System.err.println(String.format("Error during parsing: %s", e.getMessage()));
			return false;
		}

		return true;
	}

	/* Executes the instructions saved during parsing */
	public void run()
	{
		if(instructions == null)
			return;

		Vector<Integer> memory = new Vector<Integer>();
		
		/* Run code until we either have executed the program
		 * until the end or we encountered a HALT instruction
		 * (which returns -1). */
		for(int pos = 0; pos < instructions.size() && pos >= 0;)
		{
			int nextpos = instructions.get(pos).run(memory, labels, pos);
			printStatus(memory, pos);
			pos = nextpos;
		}
	}

	/* Prints current line in code and the memory */
	public void printStatus(Vector<Integer> memory, int pos)
	{
		/* Fetch line in original code (starting with 1!) */
		int currentLine = instructions.get(pos).getLine();

		System.out.printf(">> line %d: %s\n", currentLine, code.get(currentLine - 1));

		for(int i=0; i < memory.size(); i++)
		{
			System.out.printf("R%-4d%10d\n", i, memory.get(i));
		}
		
		System.out.printf("\n");
	}

	public static void main(String[] args)
	{
		BufferedReader inReader = null;
		StringBuilder builder = new StringBuilder(); // Saves code in one piece
		Vector<String> lines = new Vector<String>(); // Saves code line by line

		if(args.length == 0 || args[0].equals("-")) // Read from stdin
		{
			inReader = new BufferedReader(new InputStreamReader(System.in));
		}
		else if(args[0].equals("--help") || args[0].equals("-h"))
		{
			System.err.print("Please give either a path or '-' for stdin.");
		}
		else  // Read from file
		{
			File f = new File(args[0]);

			if(!f.exists())
			{
				System.err.println("Could not find file " + args[0]);
				System.exit(1);
			}
			
			if(!f.canRead())
			{
				System.err.println("Could not read file " + args[0]);
				System.exit(1);
			}

			try
			{
				inReader = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
			}
			catch(FileNotFoundException e)
			{
				System.err.println("Could not find file " + args[0] + ": " + e.getMessage());
				System.exit(1);
			}
		}
	
		while(true)
		{
			String buf = null;

			try
			{
				buf = inReader.readLine();
			}
			catch(IOException e)
			{
				System.err.println("Error reading:" + e.getMessage());
				System.exit(1);
			}

			if(buf == null)
			{
				break;
			}

			builder.append(buf);
			builder.append("\n");
			lines.add(buf.trim());
		}

		/* This constructor is generated by javacc */
		RamInterpreter interpreter = new RamInterpreter(new StringReader(builder.toString()));
		interpreter.setCode(lines);
		
		if(interpreter.parse())
		{
			interpreter.run();
		}
	}
}

PARSER_END(RamInterpreter)

SKIP :
{
	" "
| 
	"\t"
|
	"\r"
}


TOKEN :
{
	< EQUAL : "=" >
|
	< PARENTHESES_LEFT : "(" >
|
	< PARENTHESES_RIGHT : ")" >
|
	< COLON : ":" >
|
	< HALT : "HALT" >
|
	< OP : "+" | "-" | "*" | "/" >
|
	< GOTO : "GOTO" >
|
	< GOTOOP : "GZ" | "GGZ" | "GLZ" >
|
	< NUMBER : ( ["0"-"9"] )+ >
|
	< REGISTER : "R" <NUMBER> >
|
	< LABEL: ( ["a"-"z","A"-"Z","0"-"9", "_","-"] )+ >
|
	< COMMENT_ONELINE : ("//" | "#") ( ~["\n"] )* >
|
	< COMMENT_MULTILINE_START : "/*" >
|
	< COMMENT_MULTILINE_END : "*/" >
|
	< LF : "\n" >
|
	< EVERYTHING : ~[] >
}

void statements(Vector<Instruction> instructions, HashMap<String,Integer> label) :
{
	Instruction instr;
	IntWrapper line = new IntWrapper(1); // allows call by reference, needed for multiline_comment()
}
{
	(
		comment(line)

		(
			(
				instr=statement(line)
				{
					instructions.add(instr);
				}
			|
				instr=jumpGoto(line)
				{
					instructions.add(instr);
				}
			|
				instr=jumpCond(line)
				{
					instructions.add(instr);
				}
			|
				instr=halt(line)
				{
					instructions.add(instr);
				}
			|
				label(instructions, label, line)
			)
	
			comment(line)
		)?

		<LF>
		{
			line.value++;
		}
	)*

	<EOF>
}

/* Skips all comments, if there are some */
void comment(IntWrapper line) : 
{

}
{
	(
		multilineComment(line)
	)*

	(
		onelineComment(line)
	)?
}

void onelineComment(IntWrapper line) :
{

}
{
	<COMMENT_ONELINE>
}

void multilineComment(IntWrapper line) :
{

}
{
	<COMMENT_MULTILINE_START>

	( // match everything except "*/"
		<EQUAL>
	|
		<PARENTHESES_LEFT>
	|
		<PARENTHESES_RIGHT>
	|
		<COLON>
	|
		<HALT>
	|
		<OP>
	|
		<GOTO>
	|
		<GOTOOP>
	|
		<NUMBER>
	|
		<REGISTER>
	|
		<LABEL>
	|
		<COMMENT_ONELINE>
	|
		<COMMENT_MULTILINE_START>
	|
		<LF>
		{
			line.value++;
		}
	|
		<EVERYTHING>
	)*

	<COMMENT_MULTILINE_END>
}

void label(Vector<Instruction> instructions, HashMap<String,Integer> labels, IntWrapper line) :
{
	Token t;
	Integer ret;
}
{
	t=<LABEL> <COLON>
	{
		ret = labels.get(t.image);

		if(ret != null) // Is there already this label somewhere else?
		{
			throw new ParseException(String.format("Encountered already definied label \"%s\" at line %d.", t.image, line.value));
		}

		labels.put(t.image, instructions.size());
	}
}

Instruction jumpCond(IntWrapper line) :
{
	Token t;
	Variable v;
	InstructionJump instr = new InstructionJump();
	InstructionJump.JumpType type;
}
{
	type=jumpCondType() ( v=address(line) | v=number(line) ) t=<LABEL>
	{
		instr.setLabel(t.image);
		instr.setJumpType(type);
		instr.setVar(v);
		instr.setLine(line);
		return instr;
	}
}

InstructionJump.JumpType jumpCondType() :
{
	Token t;
}
{
	t=<GOTOOP>
	{
		if(t.image.equals("GZ"))
		{
			return InstructionJump.JumpType.GZ;
		}
		else if(t.image.equals("GGZ"))
		{
			return InstructionJump.JumpType.GGZ;
		}
		else // => GLZ
		{
			return InstructionJump.JumpType.GLZ;
		}
	}
}

Instruction jumpGoto(IntWrapper line) :
{
	Token t;
	InstructionJump instr = new InstructionJump();
}
{
	<GOTO> t=<LABEL>
	{
		instr.setLabel(t.image);
		instr.setJumpType(InstructionJump.JumpType.GOTO);
		instr.setLine(line);
		return instr;
	}
}

Instruction halt(IntWrapper line) :
{
	Token t;
}
{
	t=<HALT>
	{
		InstructionHalt instr = new InstructionHalt();
		instr.setLine(line);
		return instr;
	}
}

/* Instruction with an assignment */
Instruction statement(IntWrapper line) :
{
	Token t;
	Variable target;
	Variable lop;
	Variable rop;
	InstructionOp.Op operationType;
	InstructionOp instr = new InstructionOp();
	instr.setOperationType(InstructionOp.Op.ASSIGN);
	instr.setLine(line);
}
{
	target=address(line)
	{
		instr.setTarget(target);
	}
	<EQUAL> ( lop=address(line) | lop=number(line) )
	{
		instr.setLeftOperant(lop);
	}
	(
		operationType=op() (rop=address(line) | rop=number(line)) /* it may be only an assignment */
		{
			instr.setRightOperant(rop);
			instr.setOperationType(operationType);
		}
	)?
	{
		return instr;
	}
}

InstructionOp.Op op() :
{
	Token t;
}
{
	t=<OP>
	{
		if(t.image.equals("+"))
		{
			return InstructionOp.Op.PLUS;
		}
		else if(t.image.equals("-"))
		{
			return InstructionOp.Op.MINUS;
		}
		else if(t.image.equals("*"))
		{
			return InstructionOp.Op.MULT;
		}
		else
		{
			return InstructionOp.Op.DIV;
		}
	}
}

Variable number(IntWrapper line) :
{
	Token t;
	Variable v;
}
{
	t=<NUMBER>
	{
		v = new Variable(Variable.Mode.NUMBER, Integer.parseInt(t.image), line);
		return v;
	}
}

Variable address(IntWrapper line) :
{
	Token t;
	Variable v;
}
{
	<PARENTHESES_LEFT> v=indirectAddress(line) <PARENTHESES_RIGHT>
	{
		  return v;
	}
|
	t=<REGISTER>
	{
		v = new Variable(Variable.Mode.DIRECT, Integer.parseInt(t.image.substring(1)), line);
		return v;
	}
}

Variable indirectAddress(IntWrapper line) :
{
	Token t;
	Variable v;
}
{
	t=<REGISTER>
	{
		v = new Variable(Variable.Mode.INDIRECT, Integer.parseInt(t.image.substring(1)), line);
		return v;
	}
|
	t=<NUMBER>
	{
		v = new Variable(Variable.Mode.DIRECT, Integer.parseInt(t.image), line);
		return v;
	}
}
